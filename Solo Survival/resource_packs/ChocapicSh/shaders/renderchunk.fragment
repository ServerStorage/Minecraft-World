/// version 300 code

	#ifdef MSAA_FRAMEBUFFER_ENABLED
		#define _centroid centroid
	#else
		#define _centroid
	#endif



	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in precision highp vec2 uv0;
			_centroid in precision highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif

	#define varying in
	#define texture2D texture
	out vec4 FragColor;
	#define gl_FragColor FragColor
#else




	// version 100 code

	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif



varying vec4 color;

#ifdef FOG
varying vec4 fogColor;
#endif


#ifdef NEAR_WATER
varying float cameraDist;
#endif

#include "shaders/util.h"



uniform sampler2D TEXTURE_0;
uniform sampler2D TEXTURE_1;
uniform sampler2D TEXTURE_2;



#define enableSSPEmapping
#define saturation 1.0
#define exposure 1.0
#define brightness 0.600
#define gamma 1.0
#define contrast 1.27

float filmic_curve(float x) {

// Shoulder strength
float A = 0.22;
// Linear strength
float B = 0.5;
// Linear angle
float C = 0.15 * brightness;
// Toe strength
float D = 0.4 * gamma;
// Toe numerator
float E = 0.01 * contrast;
// Toe denominator
float F = 0.2;

return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;

}

vec3 doSSPEmapping(vec3 clr) {

float W = 1.0 / exposure;

#ifdef enableSSPEmapping

float Luma = dot(clr, vec3(0.0, 0.3, 0.3));
vec3 Chroma = clr - Luma;
clr = (Chroma * saturation) + Luma;

  clr = vec3(filmic_curve(clr.r), filmic_curve(clr.g), filmic_curve(clr.b)) / filmic_curve(W);
#endif

return clr;
}



void main()
{


#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(0, 0, 0, 0);
	return;
#else 

#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
	vec4 diffuse = texture2D( TEXTURE_0, uv0 );
#else
	vec4 diffuse = texture2D_AA(TEXTURE_0, uv0 );
#endif


	vec4 inColor = color;
float torchlightaffects = (1.0 - uv1.x);

vec3 SSPETorch = vec3(0.45,0.2,-0.3);
vec3 SSPETorch2 = vec3(0.4,0.01,0.01);

vec3 SSPEWorld1 = vec3(0.135,0.127,0.25);
vec3 SSPEWorld2 = vec3(0.0,0.0,0.011);


vec2 DAY_NIGHT_COLORS = vec2(2.9647058823529413, 1.5843137254901962);
vec4 skyLightColor = texture2D(TEXTURE_1, vec2(0.0, 1.0));
float col = dot(skyLightColor.rgb, vec3(1.0));
float time = (DAY_NIGHT_COLORS.x - col)/(DAY_NIGHT_COLORS.x - DAY_NIGHT_COLORS.y);



#ifdef SEASONS_FAR
	diffuse.a = 1.0;
	inColor.b = 1.0;
#endif

#ifdef ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
		float alphaThreshold = .05;
	#else
		float alphaThreshold = .5;
	#endif
	if(diffuse.a < alphaThreshold)
		discard;
#endif
	
#if !defined(ALWAYS_LIT)
	diffuse = diffuse * texture2D( TEXTURE_1, uv1 );
#endif

#ifndef SEASONS

#if !defined(ALPHA_TEST) && !defined(BLEND)
	diffuse.a = inColor.a;
#elif defined(BLEND)
	diffuse.a *= inColor.a;
	#ifdef NEAR_WATER
		float alphaFadeOut = clamp(cameraDist, 0.0, 1.0);
		diffuse.a = mix(diffuse.a, 1.0, alphaFadeOut);
	#endif
#endif	
	
	diffuse.rgb *= inColor.rgb;
#else
	vec2 uv = inColor.xy;
	diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	diffuse.rgb *= inColor.aaa;
	diffuse.a = 1.0;
#endif



float s_amount = 0.0;
float nolight = (1.0 - uv1.x);

if(uv1.y < 0.875){s_amount = 0.05;}
if(uv1.y < 0.874){s_amount = 0.10;}
if(uv1.y < 0.873){s_amount = 0.15;}
if(uv1.y < 0.872){s_amount = 0.20;}
if(uv1.y < 0.871){s_amount = 0.25;}
if(uv1.y < 0.870){s_amount = 0.30;}
if(uv1.y < 0.869){s_amount = 0.35;}
if(uv1.y < 0.868){s_amount = 0.40;}
if(uv1.y < 0.867){s_amount = 0.45;}

vec3 SSPEshadow = vec3(0.0,0.0,0.0);

diffuse.rgb = mix(diffuse.rgb, SSPEshadow.rgb, s_amount * nolight * torchlightaffects);


#ifdef FOG
	s_amount = max(9.0, s_amount - fogColor.a * 9.0);
#endif





#ifdef FOG
	diffuse.rgb = mix( diffuse.rgb, fogColor.rgb, fogColor.a *1.0 );
#endif

//diffuse += vec4(diffuse.rgb*diffuse.rgb*0.750*diffuse.b,diffuse.b);

diffuse.rgb += diffuse.rgb*(SSPETorch.rgb*3.0)*max(0.0,uv1.x-0.6);
diffuse.rgb += diffuse.rgb*(SSPETorch2.rgb*3.0)*max(0.0,uv1.x-0.5);

//diffuse.rgb += SSPETorch*max(0.0,uv1.x-0.6);
//diffuse.rgb += SSPETorch2*max(0.0,uv1.x-0.5);

diffuse.rgb += SSPEWorld1*max(0.20,uv1.x-0.5); 
diffuse.rgb += SSPEWorld2*min(0.30,uv1.x-0.5);

diffuse.rgb = doSSPEmapping(diffuse.rgb); 

//gl_FragColor = vec4( color, 1.0 );
	gl_FragColor = diffuse;
 

#endif // BYPASS_PIXEL_SHADER
}
